# Ariadne Metadata Management System - Execution Plan Overview

## Project Overview

**Project Codename**: Ariadne  
**Project Type**: Enterprise Metadata Management System  
**Development Timeline**: 22 weeks (approximately 5.5 months)  
**Development Model**: Three-Agent Parallel Development

### Core Objectives

1. **Cross-Source Metadata Management**: Support Oracle, MongoDB, Elasticsearch, and future extensible data sources
2. **Dual-Level Lineage Tracking**: Table-level and field-level lineage relationship management
3. **Manual & Bulk Management**: Support manual CRUD operations and bulk import/export
4. **AI-Powered Assistant**: Natural language metadata querying based on RAG
5. **Business Semantics Layer**: Data definitions and business glossary management

### Lineage Source Classification

The system explicitly distinguishes three types of lineage sources:
- **Inferred**: Automatically derived lineage relationships (gray dashed lines)
- **Manual**: User-created lineage relationships (blue solid lines)
- **Approved**: Lineage relationships reviewed and approved by data stewards (green solid lines)

---

## Technology Stack

### Backend Stack

| Component | Technology | Rationale |
|-----------|-----------|-----------|
| Language | **Python 3.11+** | Mature AI ecosystem, strong data processing |
| Web Framework | **FastAPI** | High-performance async framework, auto-generates OpenAPI docs |
| ORM | **SQLAlchemy 2.0** | Mature Python ORM with async support |
| Metadata Database | **PostgreSQL 15+** | Strong JSON support, data integrity guarantees |
| Vector Database | **pgvector** | PostgreSQL native extension, simplified architecture |
| Graph Database | **Neo4j 5.x** | Industry-leading graph database, excellent lineage query performance |
| Cache | **Redis 7.x** | High-performance cache, supports multiple data structures |
| Task Queue | **Celery + Redis** | Async task processing (bulk imports, etc.) |
| API Documentation | **Swagger UI** | Auto-generated by FastAPI |

### Frontend Stack

| Component | Technology | Rationale |
|-----------|-----------|-----------|
| Framework | **React 18 + TypeScript** | Component-based development, type safety |
| Build Tool | **Vite** | Lightning-fast dev experience |
| State Management | **Zustand** | Lightweight, easy to use |
| UI Library | **Ant Design 5.x** | Enterprise-grade UI components |
| Graph Visualization | **ReactFlow** | Interactive flow diagrams, excellent performance |
| Data Tables | **Ant Design Table** | Feature-rich enterprise tables |
| HTTP Client | **Axios** | Supports interceptors, easy auth integration |
| Routing | **React Router 6** | Declarative routing |

### AI/ML Stack

| Component | Technology | Rationale |
|-----------|-----------|-----------|
| LLM API | **OpenAI GPT-4 / Claude 3** | High-quality natural language understanding |
| Embedding Model | **OpenAI text-embedding-3** | High-quality vector representations |
| RAG Framework | **LangChain** | Mature RAG pipeline framework |
| Vector Storage | **pgvector** | Unified with main database |

### Infrastructure

| Component | Technology |
|-----------|-----------|
| Containerization | Docker + Docker Compose |
| CI/CD | GitHub Actions |
| Monitoring | Prometheus + Grafana |
| Logging | Structured logging (structlog) + ELK Stack (optional) |

---

## System Architecture

### Architecture Diagram

```
┌─────────────────────────────────────────────────────────────┐
│                    Frontend Layer (React)                     │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐      │
│  │ Metadata     │  │ Lineage      │  │ AI           │      │
│  │ Browser      │  │ Visualizer   │  │ Assistant    │      │
│  └──────────────┘  └──────────────┘  └──────────────┘      │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐      │
│  │ Manual       │  │ Bulk Import  │  │ Admin        │      │
│  │ Editor       │  │ Wizard       │  │ Console      │      │
│  └──────────────┘  └──────────────┘  └──────────────┘      │
└─────────────────────────────────────────────────────────────┘
                            ↕ HTTPS/WebSocket
┌─────────────────────────────────────────────────────────────┐
│                   API Gateway Layer (FastAPI)                 │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐      │
│  │ Auth/Authz   │  │ Rate Limit   │  │ API Routes   │      │
│  └──────────────┘  └──────────────┘  └──────────────┘      │
└─────────────────────────────────────────────────────────────┘
                            ↕
┌─────────────────────────────────────────────────────────────┐
│                    Service Layer (Python)                     │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐      │
│  │ Metadata     │  │ Lineage      │  │ Connector    │      │
│  │ Service      │  │ Service      │  │ Framework    │      │
│  └──────────────┘  └──────────────┘  └──────────────┘      │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐      │
│  │ Import/      │  │ AI Service   │  │ Search       │      │
│  │ Export       │  │              │  │ Service      │      │
│  └──────────────┘  └──────────────┘  └──────────────┘      │
└─────────────────────────────────────────────────────────────┘
                            ↕
┌─────────────────────────────────────────────────────────────┐
│                        Data Layer                             │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐      │
│  │ PostgreSQL   │  │ Neo4j        │  │ Redis        │      │
│  │ (Metadata+   │  │ (Lineage     │  │ (Cache)      │      │
│  │  Vectors)    │  │  Graph)      │  │              │      │
│  └──────────────┘  └──────────────┘  └──────────────┘      │
└─────────────────────────────────────────────────────────────┘
```

### Data Flow Design

1. **Metadata Sync Flow**:
   ```
   Data Source → Connector → Metadata Service → PostgreSQL
                                              ↓
                                         Vector Service → pgvector
   ```

2. **Lineage Creation Flow**:
   ```
   User/System → Lineage Service → Neo4j → Cache Update
   ```

3. **AI Query Flow**:
   ```
   User Question → Embedding → pgvector Similarity Search → Retrieve Context
                                                          ↓
                                                     LangChain → LLM → Answer
                                                          ↑
                                                     Neo4j (Lineage Query)
   ```

---

## Database Design

### PostgreSQL Metadata Schema

#### 1. Data Sources Table

```sql
CREATE TABLE data_sources (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL UNIQUE,
    type VARCHAR(50) NOT NULL,
    connection_config JSONB NOT NULL,
    description TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    created_by VARCHAR(100),

    CONSTRAINT valid_source_type CHECK (type IN ('oracle', 'mongodb', 'elasticsearch'))
);

CREATE INDEX idx_data_sources_type ON data_sources(type);
CREATE INDEX idx_data_sources_is_active ON data_sources(is_active);
```

#### 2. Metadata Tables

```sql
CREATE TABLE metadata_tables (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    source_id UUID NOT NULL REFERENCES data_sources(id) ON DELETE CASCADE,
    name VARCHAR(255) NOT NULL,
    schema_name VARCHAR(255),
    qualified_name VARCHAR(512) GENERATED ALWAYS AS (
        schema_name || '.' || name
    ) STORED,
    type VARCHAR(50) DEFAULT 'table',
    description TEXT,
    business_definition TEXT,
    tags JSONB DEFAULT '[]',
    custom_properties JSONB DEFAULT '{}',
    row_count BIGINT,
    size_bytes BIGINT,
    last_synced_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    created_by VARCHAR(100),
    version INTEGER DEFAULT 1,

    UNIQUE(source_id, schema_name, name)
);

CREATE INDEX idx_metadata_tables_source ON metadata_tables(source_id);
CREATE INDEX idx_metadata_tables_name ON metadata_tables(name);
CREATE INDEX idx_metadata_tables_qualified_name ON metadata_tables(qualified_name);
CREATE INDEX idx_metadata_tables_tags ON metadata_tables USING GIN (tags);
CREATE INDEX idx_metadata_tables_fts ON metadata_tables
    USING GIN (to_tsvector('english', name || ' ' || COALESCE(description, '')));
```

#### 3. Metadata Fields Table

```sql
CREATE TABLE metadata_fields (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    table_id UUID NOT NULL REFERENCES metadata_tables(id) ON DELETE CASCADE,
    name VARCHAR(255) NOT NULL,
    data_type VARCHAR(100),
    is_nullable BOOLEAN DEFAULT TRUE,
    is_primary_key BOOLEAN DEFAULT FALSE,
    is_foreign_key BOOLEAN DEFAULT FALSE,
    default_value TEXT,
    description TEXT,
    business_definition TEXT,
    tags JSONB DEFAULT '[]',
    custom_properties JSONB DEFAULT '{}',
    ordinal_position INTEGER,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    created_by VARCHAR(100),
    version INTEGER DEFAULT 1,

    UNIQUE(table_id, name)
);

CREATE INDEX idx_metadata_fields_table ON metadata_fields(table_id);
CREATE INDEX idx_metadata_fields_name ON metadata_fields(name);
CREATE INDEX idx_metadata_fields_tags ON metadata_fields USING GIN (tags);
```

#### 4. Change History Table

```sql
CREATE TABLE metadata_history (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    entity_type VARCHAR(50) NOT NULL,
    entity_id UUID NOT NULL,
    operation VARCHAR(20) NOT NULL,
    old_value JSONB,
    new_value JSONB,
    changed_by VARCHAR(100),
    changed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    change_reason TEXT
);

CREATE INDEX idx_metadata_history_entity ON metadata_history(entity_type, entity_id);
CREATE INDEX idx_metadata_history_changed_at ON metadata_history(changed_at DESC);
```

#### 5. Vector Embeddings Table

```sql
CREATE EXTENSION IF NOT EXISTS vector;

CREATE TABLE metadata_embeddings (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    entity_type VARCHAR(50) NOT NULL,
    entity_id UUID NOT NULL,
    embedding vector(1536),
    content_hash VARCHAR(64),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    UNIQUE(entity_type, entity_id)
);

CREATE INDEX idx_embeddings_vector ON metadata_embeddings
    USING hnsw (embedding vector_cosine_ops);

CREATE INDEX idx_embeddings_entity ON metadata_embeddings(entity_type, entity_id);
```

### Neo4j Graph Database Model

#### Node Types

```cypher
(:Table {
  id: String,
  name: String,
  qualifiedName: String,
  source: String,
  type: String
})

(:Field {
  id: String,
  name: String,
  tableId: String,
  dataType: String,
  isPrimaryKey: Boolean
})
```

#### Relationship Types

```cypher
(:Table)-[:FEEDS_INTO {
  transformationType: String,
  transformationLogic: String,
  confidence: Float,
  lineageSource: String,
  createdBy: String,
  createdAt: DateTime,
  approvedBy: String,
  approvedAt: DateTime,
  metadata: Map
}]->(:Table)

(:Field)-[:DERIVES_FROM {
  transformationLogic: String,
  confidence: Float,
  lineageSource: String,
  createdBy: String,
  createdAt: DateTime,
  approvedBy: String,
  approvedAt: DateTime
}]->(:Field)

(:Table)-[:HAS_FIELD]->(:Field)
```

#### Index Design

```cypher
CREATE CONSTRAINT table_id_unique FOR (t:Table) REQUIRE t.id IS UNIQUE;
CREATE CONSTRAINT field_id_unique FOR (f:Field) REQUIRE f.id IS UNIQUE;

CREATE INDEX table_name_idx FOR (t:Table) ON (t.name);
CREATE INDEX table_qualified_name_idx FOR (t:Table) ON (t.qualifiedName);
CREATE INDEX field_name_idx FOR (f:Field) ON (f.name);
```

---

## Three-Agent Responsibility Division

### Backend Architecture Agent

**Core Responsibility**: Design and implementation of data layer, service layer, and API layer

**Main Deliverables**:
- Database schema design and migration scripts
- RESTful API implementation (FastAPI)
- Connector framework (Oracle/MongoDB/Elasticsearch)
- Lineage service (graph database operations)
- Bulk import/export service
- AI service (RAG pipeline, vector search)
- Authentication/authorization middleware
- Unit tests and integration tests

**Tech Stack**: Python, FastAPI, SQLAlchemy, Neo4j Python Driver, LangChain, pgvector

---

### Frontend Experience & Visualization Agent

**Core Responsibility**: User interface, interaction experience, data visualization

**Main Deliverables**:
- Metadata browser interface
- Interactive lineage graph visualization
- Manual metadata editing forms
- Bulk import wizard (multi-step form)
- AI chat interface
- Search and filtering functionality
- Responsive layout and accessibility
- Frontend unit tests and E2E tests

**Tech Stack**: React, TypeScript, Ant Design, ReactFlow, Zustand, Axios

---

### Overall Architecture & Quality Control Agent

**Core Responsibility**: Architecture review, quality assurance, testing strategy, deployment readiness

**Main Deliverables**:
- Architecture Decision Records (ADR)
- API contract testing
- Performance benchmarking
- Security audits
- CI/CD pipeline configuration
- Monitoring and alerting setup
- Documentation completeness review
- Deployment guide

**Working Mode**:
- Part-time mode during parallel development phases (review)
- Full-time mode during integration phase (quality gatekeeper)
- Does not design features but ensures all deliverables meet quality standards

---

## Development Phase Planning

### Overall Timeline (22 weeks)

```
Week 1-2   | Phase 0: Foundation & Planning                      | All Agents Collaborate
Week 3-5   | Phase 1: Core Infrastructure                        | Parallel Development Begins ✅ COMPLETE
Week 6-8   | Phase 2: Data Source Connection + Manual Lineage   | Parallel Development
Week 9-12  | Phase 3: Lineage Engine Enhancement                 | Parallel Development (Critical Path)
Week 13-15 | Phase 4: AI Integration                             | Parallel Development (Critical Path)
Week 16-19 | Phase 5: Metadata Extraction & Auto-Sync            | Parallel Development
Week 20-22 | Phase 6: Integration, Optimization & Deployment     | All Agents Collaborate
```

**Key Change**: Phase 2 now focuses on connection testing and manual lineage management. Full metadata extraction is deferred to Phase 5.

### Phase 0: Foundation & Planning (Week 1-2)

**Objective**: Complete all foundational decisions, establish dev environment, define API contracts

**Key Milestones**:
- Technology stack finalized
- Database schema design completed
- API contract (OpenAPI spec) defined
- Development environment setup guide
- CI/CD pipeline basic configuration

### Phase 1: Core Infrastructure (Week 3-5)

**Objective**: Establish basic CRUD operations, implement authentication/authorization

**Key Milestones**:
- Database deployment complete (PostgreSQL + Neo4j)
- Basic APIs running (CRUD for sources, tables, fields)
- Frontend basic framework (login, layout, routing)
- End-to-end basic flow working

### Phase 2: Data Source Connection + Manual Lineage Management (Week 6-8)

**Objective**: Implement data source connection testing and manual lineage documentation

**Key Innovation**: Smart Metadata Assist - On-demand column retrieval for manual tables

**Key Milestones**:
- Data source CRUD with connection testing (Oracle/MongoDB/Elasticsearch)
- Smart metadata assist: Fetch columns from connected sources
- Manual table/field CRUD (source_id now optional)
- Neo4j lineage graph setup
- Manual lineage relationship creation
- Lineage visualization with ReactFlow
- Bulk import/export (CSV/Excel/JSON/YAML)

**Architecture Change**: `source_id` in `metadata_tables` is now nullable to support manual tables

### Phase 3: Lineage Engine Enhancement (Week 9-12) ⚠️ Critical Path

**Objective**: Enhance lineage graph capabilities with advanced queries and analysis

**Key Milestones**:
- Graph traversal algorithms (upstream/downstream, multi-hop)
- Impact analysis and root cause analysis
- Advanced lineage queries with filtering
- Performance optimization (1000+ node graphs, < 500ms for 3-hop queries)
- Lineage approval workflow
- Lineage confidence scoring

### Phase 4: AI Integration (Week 13-15) ⚠️ Critical Path

**Objective**: Implement AI intelligent assistant with RAG

**Key Milestones**:
- Vector embedding generation and storage (pgvector)
- RAG pipeline implementation (LangChain)
- Natural language query interface
- AI chat interface with conversation history
- Semantic search for metadata
- Lineage explanation generation

### Phase 5: Metadata Extraction & Auto-Sync (Week 16-19)

**Objective**: Implement automated metadata extraction from data sources

**Key Milestones**:
- Oracle metadata extraction (system catalogs: ALL_TABLES, ALL_TAB_COLUMNS)
- MongoDB schema inference (sampling and analysis)
- Elasticsearch mapping extraction
- Automated sync with conflict resolution (merge/keep/replace)
- Incremental sync and change detection
- Permission handling and error recovery
- "Inferred" lineage generation from metadata patterns

### Phase 6: Integration, Optimization & Deployment (Week 20-22)

**Objective**: System integration, performance optimization, production readiness

**Key Milestones**:
- End-to-end integration testing
- Performance optimization (<200ms API response)
- Security hardening
- Monitoring and alerting configuration
- Documentation completion
- User acceptance testing

---

## API Contract Overview

### Metadata Management API

```
GET    /api/v1/sources
POST   /api/v1/sources
GET    /api/v1/sources/{id}/sync

GET    /api/v1/tables
GET    /api/v1/tables/{id}
POST   /api/v1/tables
PUT    /api/v1/tables/{id}
DELETE /api/v1/tables/{id}

GET    /api/v1/tables/{id}/fields
POST   /api/v1/fields
PUT    /api/v1/fields/{id}
DELETE /api/v1/fields/{id}

GET    /api/v1/tables/{id}/history
```

### Lineage Management API

```
GET    /api/v1/lineage/table/{id}/upstream
GET    /api/v1/lineage/table/{id}/downstream
GET    /api/v1/lineage/field/{id}/upstream
GET    /api/v1/lineage/field/{id}/downstream

POST   /api/v1/lineage/table
POST   /api/v1/lineage/field
PUT    /api/v1/lineage/{id}
DELETE /api/v1/lineage/{id}

POST   /api/v1/lineage/{id}/approve
GET    /api/v1/lineage/impact/{id}
```

### Bulk Operations API

```
POST   /api/v1/import/validate
POST   /api/v1/import/execute
GET    /api/v1/import/jobs/{id}

GET    /api/v1/export/metadata
GET    /api/v1/export/lineage
```

### AI Assistant API

```
POST   /api/v1/ai/query
POST   /api/v1/ai/search
GET    /api/v1/ai/conversations
POST   /api/v1/ai/feedback
```

### Search API

```
GET    /api/v1/search
GET    /api/v1/search/semantic
```

---

## Risk Management

### High-Risk Items

| Risk | Impact | Mitigation Strategy |
|------|--------|---------------------|
| **Lineage Graph Performance Bottleneck** | High | Early performance testing (Phase 3), Neo4j index optimization, caching strategy, depth-limited queries |
| **AI Hallucination Issues** | High | Retrieval-based answers (RAG), show source citations, user feedback mechanism, confidence scores |
| **Bulk Import Data Quality** | Medium | Multi-layer validation (syntax, semantics, business rules), preview confirmation mechanism, transactional processing, detailed error reporting |
| **Parallel Development Sync** | Medium | API contract testing, weekly integration checkpoints, QC Agent oversight |
| **Connector Stability** | Medium | Connection pool management, retry mechanisms, health checks, manual override functionality |

### Quality Gates

**Each phase must pass the following gates before proceeding to the next**:

1. All planned features implemented
2. Unit test coverage ≥ 80%
3. API contract tests passing
4. Performance benchmarks met
5. Security review passed
6. Documentation updated
7. QC Agent approval

---

## Agent Collaboration Protocol

### Synchronization Mechanisms

1. **Daily Async Standup** (Slack/Discord)
   - Yesterday's completion
   - Today's plan
   - Blocking issues

2. **Weekly Integration Checkpoint**
   - Demo completed features
   - API contract alignment check
   - Integration issue resolution

3. **Phase Review Meeting**
   - All deliverables review
   - QC Agent quality assessment
   - Next phase planning confirmation

### Shared Artifacts

- **API Contract**: OpenAPI 3.0 spec (docs/api/openapi.yaml)
- **Data Models**: TypeScript type definitions (shared-types package)
- **Database Schema**: SQL migration files (migrations/)
- **ADR Documents**: Architecture Decision Records (docs/adr/)

### Conflict Resolution

- API contract disputes → QC Agent arbitrates
- Performance trade-offs → QC Agent evaluates based on benchmarks
- UX vs technical feasibility → Joint discussion and decision

---

## Success Criteria

### Functional Metrics

- Support Oracle, MongoDB, Elasticsearch data sources
- Metadata sync functionality working (10,000+ tables)
- Complete manual create/edit metadata flow
- Lineage visualization supports 1,000+ node graphs
- Bulk import 10,000+ records without errors
- AI natural language query accuracy ≥ 85%

### Performance Metrics

- API response time (P95) < 200ms
- Lineage query (3-hop) < 500ms
- AI query response < 3 seconds
- Frontend first paint < 2 seconds
- Support 100+ concurrent users

### Quality Metrics

- Backend test coverage ≥ 80%
- Frontend test coverage ≥ 70%
- Security scan 0 critical vulnerabilities
- WCAG 2.1 AA accessibility compliance
- Documentation completeness 100%

---

## Next Steps

1. **Backend Agent**: Read `docs/backend-execution-plan.md`
2. **Frontend Agent**: Read `docs/frontend-execution-plan.md`
3. **QC Agent**: Read `docs/qc-execution-plan.md`
4. **All**: Phase 0 kickoff meeting (confirm tech stack and API contract)

---

**Document Version**: v1.1
**Last Updated**: 2025-12-23
**Maintainer**: QC Agent (Claude)
**Change Log**:
- v1.1 (2025-12-23): Revised Phase 2 to focus on connection testing + manual lineage; deferred metadata extraction to Phase 5
- v1.0 (2025-12-21): Initial version
